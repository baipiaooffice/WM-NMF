classdef lime
%lime Local interpretable model-agnostic explanations (LIME)
%    Explains a prediction of a machine learning model (classification or
%    regression) model locally around a data instance using LIME.
%
%    Create a lime object for a machine learning model with a specified 
%    query point and a specified number of important predictors. The software 
%    generates a synthetic data set and fits a simple interpretable model 
%    of important predictors that effectively explains the predictions for 
%    the synthetic data around the query point. The simple model can be a 
%    linear model (default) or decision tree model.
%
%    lime Properties:
%         BlackboxFitted         - Blackbox model's response for the query point
%         BlackboxModel          - Model to be explained
%         CategoricalPredictors  - Categorical predictors indices
%         DataLocality           - Global or local synthetic data to be generated
%         Fitted                 - Blackbox model's response vector for synthetic data 
%         ImportantPredictors    - Predictors chosen to be important by lime
%         NumImportantPredictors - Number of important predictors to choose
%         NumSyntheticData       - Number of synthetic data observations to be
%                                  generated
%         QueryPoint             - Observation around which an explanation is to
%                                  be provided
%         SimpleModel            - Simple model that is fitted
%         SimpleModelFitted      - Simple model's response for the query point
%         SyntheticData          - Data generated by lime that is similar to the 
%                                  blackbox model's training data
%         Type                   - Classification or regression model
%         X                      - (data like) training data of the blackbox model
%
%    lime Methods:
%        lime - Create a lime object
%        fit  - Fit a simple model for a new query point
%        plot - Provide a visualization for the explanation
%
%    Example 1: LIME for table data
%             tbl = readtable('fisheriris.csv','format','%f%f%f%f%C');
%
%             % Create a blackbox model
%             blackbox = fitcensemble(tbl,'Species','Method','Bag','NumLearningCycles',4);
% 
%             % Use lime to get explanations for the blackbox model for around the first test point
%             results = lime(blackbox);
%             results = fit(results,tbl(1,1:end-1),1);
% 
%             % Plot the explanations. This plot consists of the important features recognized by lime locally around the point
%             f = plot(results);

%    Copyright 2020 The MathWorks, Inc.

   properties(GetAccess=public,SetAccess=private)
        %BlackboxModel Machine learning model to be interpreted, specified as a regression
        %    or classification model object or a function handle.
        BlackboxModel;
        
        %DataLocality Locality of synthetic data, specified as 'global' or 'local'.
        DataLocality;
        
        %CategoricalPredictors Categorical predictor indices, specified as 
        %    a vector of positive integers. CategoricalPredictors contains 
        %    index values corresponding to the columns of the predictor 
        %    data that contain categorical predictors. 
        CategoricalPredictors;
        
        %Type Type of the machine learning model, specified as 'regression'
        %    or 'classification'.
        Type;
        
        %X Predictor data, specified as a numeric matrix or table. Each row
        %    of X corresponds to one observation, and each column corresponds
        %    to one variable.
        X;
        
        %QueryPoint Query point at which lime explains a prediction using 
        %    the simple model, specified as a row vector of numeric
        %    values or single-row table.
        QueryPoint;
        
        %NumImportantPredictors Number of important predictors to use in 
        %    the simple model, specified as a positive integer scalar value.
        NumImportantPredictors;
        
        %NumSyntheticData Number of samples in the synthetic data set, 
        %    specified as positive integer scalar value.
        NumSyntheticData;
        
        %SyntheticData Synthetic predictor data, specified as a numeric 
        %    matrix. If you specify the customSyntheticData input argument, 
        %    then the argument sets this property. Otherwise, lime estimates
        %    distribution parameters from the predictor data X and generates
        %    a synthetic predictordata set.
        SyntheticData;
        
        %Fitted Predictions for synthetic predictor data computed by using 
        %    the machine learning model, specified as a vector.
        Fitted;
        
        %SimpleModel Simple model, specified as a RegressionLinear, 
        %    RegressionTree, ClassificationLinear, or ClassificationTree 
        %    model object.
        SimpleModel;
        
        %ImportantPredictors Important predictor indices, specified as a 
        %    vector of positive integers. ImportantPredictors contains 
        %    index values corresponding to the columns of the predictors 
        %    used in the simple model.
        ImportantPredictors;
        
        %BlackboxFitted Prediction for the query point computed by using 
        %    the machine learning model, specified as a scalar.
        BlackboxFitted;
        
        %SimpleModelFitted Prediction for the query point computed by using
        %    the simple model, specified as a scalar.
        SimpleModelFitted;
    end
    
    properties(GetAccess=private,SetAccess=private)
        Xmtx; %matrix form of X with levels for categorical predictors
        QPmtx; %matrix form of QueryPoint with levels for categorical predictors
        SDmtx; %matrix form of SyntheticData with levels for categorical predictors
        VariableNames;
        ResponseName;
        SimpleModelType;
        KernelWidth;
        Weights;
        AlphabetX;
        MinSD;
        MaxSD;
        DistanceFcn;
        DummyX; %X after dummifying categorical predictors
        DistanceParam;
        Groups;
        Features;
        ContLogical; %logical vector representing continuous and categorical predictors
        NumNeighbors;
    end
    
    methods
        function obj = lime(model,varargin)
%LIME Create a lime object
%    RESULTS = LIME(BLACKBOX)
%
%    BLACKBOX is a full regression or classification model object, which 
%    contains predictor data and has a predict object function.
% 
%    RESULTS = LIME(BLACKBOX,X) is an alternate syntax that accepts X 
%    containing predictors on which the blackbox model was trained, or
%    predictors similar to the training data of the blackbox model.
%
%    BLACKBOX is the trained model or a function handle that is to be interpretted.
%    It can be one of the following:
%      1. Regression or classification model object, which has a predict object function
%      2. A function handle which takes predictors X and outputs response Y 
%         either in the form of class labels (for classification) or predictions 
%        (for regression)
%
%    RESULTS = LIME(BLACKBOX,'CUSTOMSYNTHETICDATA',customSyntheticData) is 
%    an alternate syntax that creates a lime object using the pregenerated 
%    custom synthetic predictor data customSyntheticData. 
%
%    customSyntheticData is pregenerated custom synthetic predictor data
%                       set, specified as a numeric matrix or table.
%
%    RESULTS = LIME(...,'QUERYPOINT',queryPoint,'NUMIMPORTANTPREDICTORS',numImportantPredictors) 
%    is an alternate syntax that also finds the specified number of 
%    important predictors and fits a linear simple model for the query point 
%    queryPoint. You can specify QUERYPOINT and NUMIMPORTANTPREDICTORS in 
%    addition to any of the input argument combinations in the previous syntaxes.
%
%    queryPoint is a vector of predictors representing the data instance
%                       around which an explanation is to be provided.
%                       It is a row vector of numeric values or a
%                       single-row table.
%
%    numImportantPredictors is the number of important features to use in 
%                       the simple model. It is a positive integer scalar.
%
%    RESULTS = LIME(...,'NAME1',val1,'NAME2',val2,...) specifies one or 
%    more of the following Name/Value pair arguments using any of the 
%    previous syntaxes:
%      'CategoricalPredictors' - List of categorical predictors. Pass
%                       'CategoricalPredictors' as one of:
%                         * A numeric vector with indices between 1 and P,
%                           where P is the number of columns of X or
%                           variables in TBL.
%                         * A logical vector of length P, where a true
%                           entry means that the corresponding column of X
%                           or TBL is a categorical variable. 
%                         * 'all', meaning all predictors are categorical.
%                         * A string array or cell array of character
%                           vectors, where each element in the array is
%                           the name of a predictor variable. The names
%                           must match variable names in table TBL.
%                       Default: for a matrix input X, no categorical
%                       predictors; for a table TBL, predictors are
%                       treated as categorical if they are strings, cell
%                       arrays of character vectors, logical, or unordered
%                       of type 'categorical'.
%      'DataLocality' - Locality of synthetic data, specified as one of 
%                       'global' or 'local'.
%                       Default: 'global'
%      'Distance' - A character vector, string scalar, or function handle
%                       specifying the distance metric. The value can be 
%                       one of the following if the predictor data includes
%                       only continuous variables:
%                         * 'euclidean' - Euclidean distance
%                         * 'seuclidean' - Standardized Euclidean distance
%                         * 'cityblock' - City Block distance
%                         * 'chebychev' - Chebychev distance 
%                         * 'minkowski' - Minkowski distance
%                         * 'mahalanobis' - Mahalanobis distance
%                         * 'cosine' - Cosine distance
%                         * 'correlation' - Correlation distance
%                         * 'spearman' - Spearman distance
%                         * function - Custom distance function handle
%                       Default: 'euclidean'
%                       The value can be one of the following for a mix of 
%                       continuous and categorical predictors:
%                       * 'goodall3' - Modified Goodall distance
%                       * 'ofd' - Occurence Frequency Distance
%                       Default: 'goodall3'
%      'P'            - A positive scalar indicating the exponent of
%                       Minkowski distance. This argument is only valid
%                       when 'Distance' is 'minkowski'. 
%                       Default: 2.
%      'Cov'          - A positive definite matrix indicating the
%                       covariance matrix when computing the Mahalanobis
%                       distance. This argument is only valid when
%                       'Distance' is 'mahalanobis'. 
%                       Default: COV(PD,'OMITROWS'), where PD is the 
%                       predictor data or synthetic predictor data.
%      'Scale'        - A vector containing nonnegative values, with
%                       length equal to the number of columns in PD, where 
%                       PD is the predictor data or synthetic predictor 
%                       data. This argument is only valid when 'Distance' 
%                       is 'seuclidean'. 
%                       Default: STD(PD,'OMITNAN').
%      'KernelWidth'  - Width of exponential kernel used to convert distance
%                       between the query point and synthetic data to weights
%                       Default: 0.75
%      'NumNeighbors' - Number of data points that represent the locality 
%                       if ‘DataLocality’ is ‘local’
%                       Default: 1500
%      'NumSyntheticData' - Number of data points to be created in the 
%                       synthetic dataset
%                       Default: 5000
%      'SimpleModelType' - Type of the simple interpretable model to be 
%                       returned, specified as a charcter vector or string 
%                       scalar. This value can be 'linear' or 'tree'.
%                       Default: 'linear'
%      'Type'         - The type of problem the blackbox model is trying to 
%                       solve. It can be one of:
%                       * 'regression'
%                       * 'classification'
%                       Default: type of the blackbox model if
%                       classification or regression model, required
%                       name-value pair if function handle 
            if nargin > 1
               [varargin{:}] = convertStringsToChars(varargin{:});
            end
            % parse arguments
            obj.BlackboxModel = model;
            
            % check if blackbox is a classreg model or a function handle
            if ~isa(obj.BlackboxModel,'classreg.learning.classif.ClassificationModel') ...
                    && ~isa(obj.BlackboxModel,'classreg.learning.regr.RegressionModel') ...
                    && ~isa(obj.BlackboxModel,'function_handle')
                error(message('stats:lime:InvalidBlackboxModel'));
            end
            
            if nargin>1 && ~ischar(varargin{1}) && ~isstring(varargin{1})
                % Put the second arg in obj.X if it is not a char
                % vector. It would be a char if it is a NV pair
                obj.X = varargin{1};
                varargin = varargin(2:end);
            end
            obj.X = getPredictorTable(obj,obj.X,'X');
         
            pnames = {'QueryPoint','NumImportantPredictors','DataLocality','NumSyntheticData','Type','CategoricalPredictors','CustomSyntheticData','Distance','P','Cov','Scale','KernelWidth','NumNeighbors','SimpleModelType'};
            dflts =  {[],[],'global',5000,[],[],[],[],[],[],[],0.75,1500,'linear'};
            [obj.QueryPoint,obj.NumImportantPredictors,obj.DataLocality,obj.NumSyntheticData,obj.Type,obj.CategoricalPredictors,obj.SyntheticData,obj.DistanceFcn,p,cov,scale,obj.KernelWidth,obj.NumNeighbors,obj.SimpleModelType] = internal.stats.parseArgs(pnames, dflts, varargin{:});
            % We need to let the user provide distance here too if they are
            % using local or just want to use the same non-default distance for all points 

            % check DataLocality
            if ~strcmpi(obj.DataLocality,'global') ...
                    && ~strcmpi(obj.DataLocality,'local')
                error(message('stats:lime:InvalidDataLocality'));
            end
            if ~isempty(obj.SyntheticData)
                if strcmpi(obj.DataLocality,'local')
                    warning(message('stats:lime:OverrideDataLocality'));
                    obj.DataLocality = 'global';
                end
                
                % Make sure it has the required form
                obj.SyntheticData = getPredictorTable(obj,obj.SyntheticData,'CustomSyntheticData');
           end
            
            % if model is a full model and no training set was provided, 
            % extract the training set
            if isempty(obj.X)
                if isa(model,'classreg.learning.FullClassificationRegressionModel')
                    obj.X = model.X;
                elseif isempty(obj.SyntheticData)
                    error(message('stats:lime:NoTrainingData'))
                end
            elseif ~istable(obj.X) && ~(isnumeric(obj.X) && ismatrix(obj.X))
                error(message('stats:lime:TrainingBadType'));
            end
            
            % assign Type if classreg model (full or compact)
            if isempty(obj.Type)
                if isa(obj.BlackboxModel,'classreg.learning.classif.ClassificationModel')
                    obj.Type = 'classification';
                elseif isa(obj.BlackboxModel,'classreg.learning.regr.RegressionModel')
                    obj.Type = 'regression';
                else
                    error(message('stats:lime:NoType'));
                end
            else
                validatestring(obj.Type,{'classification','regression'});
            end
            if ~isa(obj.BlackboxModel,'function_handle')
                if isa(obj.BlackboxModel,'classreg.learning.classif.ClassificationModel')
                    modtype = 'classification';
                elseif isa(obj.BlackboxModel,'classreg.learning.regr.RegressionModel')
                    modtype = 'regression';
                end
                if ~strcmpi(obj.Type,modtype)
                    error(message('stats:lime:InvalidType'));
                end
            end
           
            % error check for valid blackbox model and synthetic data - takes x and returns vector y
            if isa(model,'function_handle') 
                % try to predict for the first data point
                if isempty(obj.SyntheticData)
                    trydata = obj.X(1,:);
                else
                    trydata = obj.SyntheticData(1,:);
                end
                try
                    fnpred = obj.BlackboxModel(trydata);
                    if istable(fnpred) || ~isscalar(fnpred)
                        error(message('stats:lime:InvalidBlackboxResponse'));                 
                    elseif strcmpi(obj.Type,'regression')
                        if ~isnumeric(fnpred)
                            error(message('stats:lime:BadRegressionOutput'));
                        end
                    end
                catch
                    error(message('stats:lime:BlackboxPredictError'));
                end
            end
            
            % Fill in VariableNames and ResponseName
            if ~isa(model,'function_handle')
                obj.ResponseName = obj.BlackboxModel.ResponseName;
                obj.VariableNames = obj.BlackboxModel.PredictorNames;
            else
                obj.ResponseName = 'Y';
                if ~isempty(obj.SyntheticData)
                    data = obj.SyntheticData;
                else
                    data = obj.X;
                end
                if istable(data)
                    obj.VariableNames = data.Properties.VariableNames;
                else
                    obj.VariableNames = cellstr(strcat('x',string(1:size(data,2))));
                end
            end
            
            % categorical predictors
            D = numel(obj.VariableNames);
            if isnumeric(obj.CategoricalPredictors) % indices of categorical predictors
                obj.CategoricalPredictors = ceil(obj.CategoricalPredictors);
                if any(obj.CategoricalPredictors<1) || any(obj.CategoricalPredictors>D)
                    error(message('stats:classreg:learning:FullClassificationRegressionModel:prepareDataCR:BadCatPredIntegerIndex', D));
                end
            elseif islogical(obj.CategoricalPredictors)
                if length(obj.CategoricalPredictors)~=D
                    error(message('stats:classreg:learning:FullClassificationRegressionModel:prepareDataCR:BadCatPredLogicalIndex', D));
                end
                idx = 1:D;
                obj.CategoricalPredictors = idx(obj.CategoricalPredictors);
            elseif ischar(obj.CategoricalPredictors) && strcmpi(obj.CategoricalPredictors,'all')
                obj.CategoricalPredictors = 1:D;
            else
                if ~ischar(obj.CategoricalPredictors) && ~iscellstr(obj.CategoricalPredictors)
                    error(message('stats:classreg:learning:FullClassificationRegressionModel:prepareDataCR:BadCatVarType'));
                end
                if ~iscellstr(obj.CategoricalPredictors)
                    obj.CategoricalPredictors = cellstr(obj.CategoricalPredictors);
                end
                if isnumeric(obj.VariableNames)
                    error(message('stats:classreg:learning:FullClassificationRegressionModel:prepareDataCR:CharCatVarWithoutVarNames'));
                end
                [tf,pos] = ismember(obj.CategoricalPredictors,obj.VariableNames);
                if any(~tf)
                    error(message('stats:classreg:learning:FullClassificationRegressionModel:prepareDataCR:BadCatVarName', ...
                        obj.CategoricalPredictors{ find( ~tf, 1, 'first' ) }));
                end
                obj.CategoricalPredictors = pos;
            end

           obj = errorCheckCategoricals(obj);
           % convert table to array as pdist2 and other functions do not
           % support tables
           % build Xmtx 
           obj.X = rmmissing(obj.X);
           obj.Xmtx = obj.X;
           if ~isempty(obj.X)
               if isa(obj.X,'table')
                    for i=1:numel(obj.CategoricalPredictors)
                        predictor = obj.CategoricalPredictors(i);
                        % error out if there are any ordinal predictors
                        if iscategorical(obj.X.(predictor)) && isordinal(obj.X.(predictor))
                            error(message('stats:lime:NoOrdinal'));
                        end
                    end
               else
                   for i=1:numel(obj.CategoricalPredictors)
                       predictor = obj.CategoricalPredictors(i);
                       if iscategorical(obj.X(:,predictor)) && isordinal(obj.X(:,predictor))
                           error(message('stats:lime:NoOrdinal'));
                       end
                   end
               end
               [obj,obj.Xmtx] = changeToLevels(obj,obj.X);
           end
           
            % assign distance based on the type of predictors
            if isempty(obj.DistanceFcn)
                if isempty(obj.CategoricalPredictors)
                    obj.DistanceFcn = 'euclidean';
                else
                    obj.DistanceFcn = 'goodall3';
                end
            end
            
            % assign distance parameter
            obj.DistanceParam = errorCheckDistParam(obj,obj.DistanceFcn,p,scale,cov);
            
            obj.ContLogical = true(1,numel(obj.VariableNames));
            if obj.CategoricalPredictors
                obj.ContLogical(obj.CategoricalPredictors)=false;
            end
            
            % if user has provided custom synthetic data
            if ~isempty(obj.SyntheticData)
                obj.NumSyntheticData = size(obj.SyntheticData,1);
                % remove rows with missing values
                obj.SyntheticData = rmmissing(obj.SyntheticData);
                % make sure all synthetic data observations did not get
                % removed
                if isempty(obj.SyntheticData) || size(obj.SyntheticData,1)==1
                    error(message('stats:lime:SmallSD'));
                end
                obj.SDmtx = obj.SyntheticData;
                obj.Fitted = predictFromModel(obj.BlackboxModel,obj.SyntheticData);
                if any(ismissing(obj.Fitted))
                    error(message('stats:lime:NaNFitted'));
                end
                if isa(obj.SyntheticData,'table')
                    obj.VariableNames = obj.SyntheticData.Properties.VariableNames;
                    if isa(model,'classreg.learning.FullClassificationRegressionModel')
                        obj.ResponseName = obj.BlackboxModel.ResponseName;
                    else
                        obj.ResponseName = 'Y';
                    end
                    for i=1:numel(obj.CategoricalPredictors)
                        predictor = obj.CategoricalPredictors(i);
                        % error out if there are any ordinal predictors
                        if iscategorical(obj.SyntheticData.(predictor)) ...
                                && isordinal(obj.SyntheticData.(predictor))
                            error(message('stats:lime:NoOrdinal'));
                        end
                    end
                else
                    for i=1:numel(obj.CategoricalPredictors)
                        predictor = obj.CategoricalPredictors(i);
                        if iscategorical(obj.SyntheticData(:,predictor)) ...
                                      && isordinal(obj.SyntheticData(:,predictor))
                            error(message('stats:lime:NoOrdinal'));
                        end
                    end
                end
                  

                [obj,obj.SDmtx] = changeToLevels(obj,obj.SyntheticData);
                
                % obj.SDmtx will be NumSyntheticData by D where D is the
                % number of predictors in X or CustomSyntheticData. MinSD
                % and MaxSD will be 1 by D vectors containing the min and
                % max of each predictor in numeric form.
                obj.MinSD = min(obj.SDmtx,[],1);
                obj.MaxSD = max(obj.SDmtx,[],1);
                obj.SDmtx = scaleData(obj,obj.SDmtx);
            end
                
            % Make sure QueryPoint has the required form
            obj.QueryPoint = getPredictorTable(obj,obj.QueryPoint,'QueryPoint');

            % perform other NV pair error checks
            obj = obj.errorCheck();

            % if local query point provided with global
            if ~isempty(obj.QueryPoint)&& ~isempty(obj.NumImportantPredictors)
                [obj,obj.QPmtx] = changeToLevels(obj,obj.QueryPoint);
                if isempty(obj.SyntheticData)
                    obj = generateData(obj);
                end
                % scale QueryPoint 
                obj.QPmtx = scaleData(obj,obj.QPmtx);
                obj = fitsm(obj);
            % if user wants to generate global data but no qp is given
            elseif strcmpi(obj.DataLocality,'global') && isempty(obj.SyntheticData)
                obj = generateData(obj);
                if xor(isempty(obj.QueryPoint), isempty(obj.NumImportantPredictors))
                    warning(message('stats:lime:NoQPAndNIP'));
                end
            end
        end
        
        function obj = fit(obj,x,k,varargin)
%FIT Fit simple model of local interpretable model-agnostic explanations (LIME) for new query point
%    RESULTS = FIT(RESULTS,QUERYPOINT,NUMIMPORTANTPREDICTORS) 
%     
%    QUERYPOINT is the data observation around which the fit function fits 
%    the simple model, specified as a row vector of numeric values or 
%    single-row table.
%
%    NUMIMPORTANTPREDICTORS is the number of important Features to use in 
%    the simple model
%
%    RESULTS = FIT(...,'NAME1',val1,'NAME2',val2,...) specifies one or more
%    of the following Name/Value pair arguments using any of the previous 
%    syntaxes:
%      'Distance'     - A character vector, string scalar, or function handle
%                       specifying the distance metric. The value can be 
%                       one of the following if the predictor data includes
%                       only continuous variables:
%                         * 'euclidean' - Euclidean distance
%                         * 'seuclidean' - Standardized Euclidean distance
%                         * 'cityblock' - City Block distance
%                         * 'chebychev' - Chebychev distance 
%                         * 'minkowski' - Minkowski distance
%                         * 'mahalanobis' - Mahalanobis distance
%                         * 'cosine' - Cosine distance
%                         * 'correlation' - Correlation distance
%                         * 'spearman' - Spearman distance
%                         * function - Custom distance function handle
%                       Default: The default value is the 'DISTANCE' value 
%                       that you specify when creating the lime object RESULTS.
%                       The value can be one of the following for a mix of 
%                       continuous and categorical predictors:
%                       * 'goodall3' - Modified Goodall distance
%                       * 'ofd' - Occurence Frequency Distance
%                       Default: The default value is the 'DISTANCE' value 
%                       that you specify when creating the lime object RESULTS.
%      'P'            - A positive scalar indicating the exponent of
%                       Minkowski distance. This argument is only valid
%                       when 'Distance' is 'minkowski'. 
%                       Default: The default value is the 'P' value that
%                       you specify when creating the lime object RESULTS.
%      'Cov'          - A positive definite matrix indicating the
%                       covariance matrix when computing the Mahalanobis
%                       distance. This argument is only valid when
%                       'Distance' is 'mahalanobis'. 
%                       Default: The default value is the 'COV' value that 
%                       you specify when creating the lime object RESULTS.
%      'Scale'        - A vector containing nonnegative values, with
%                       length equal to the number of columns in X. This
%                       argument is only valid when 'Distance' is
%                       'seuclidean'. 
%                       Default: The default value is the 'SCALE' value 
%                       that you specify when creating the lime object RESULTS.
%      'KernelWidth'  - Width of exponential kernel used to convert distance
%                       between the query point and synthetic data to weights
%                       Default: The default value is the 'KERNELWIDTH' value 
%                       that you specify when creating the lime object RESULTS.
%      'NumNeighbors' - Number of neighbors of the query point. This 
%                       argument is valid only when the DataLocality 
%                       property of RESULTS is 'local'.
%                       Default: The default value is the 'NUMNEIGHBORS' value 
%                       that you specify when creating the lime object RESULTS.
%      'NumSyntheticData' - Number of data points to be created in the 
%                       synthetic data set
%                       Default: The default value is the 'NUMSYNTHETICDATA' value 
%                       that you specify when creating the lime object RESULTS.
%      'SimpleModelType' - Type of the simple interpretable model to be 
%                       returned, specified as a charcter vector or string 
%                       scalar. This value can be 'linear' or 'tree'.
%                       Default: The default value is the 'SIMPLEMODELTYPE' value 
%                       that you specify when creating the lime object RESULTS.

            
            if nargin > 3
               [varargin{:}] = convertStringsToChars(varargin{:});
            end
            
            pnames = {'NumNeighbors','Distance','P','Cov','Scale','KernelWidth','SimpleModelType','NumSyntheticData'};
            dflts =  {obj.NumNeighbors,obj.DistanceFcn,[],[],[],obj.KernelWidth,obj.SimpleModelType,obj.NumSyntheticData};
            [numNei,d,dp,dcov,dscale,kw,smtype,numsd] = internal.stats.parseArgs(pnames, dflts, varargin{:});
            
            dparam = errorCheckDistParam(obj,d,dp,dscale,dcov);
            
            % if old query point
            if isequal(x,obj.QueryPoint) && isequal(k,obj.NumImportantPredictors) ...
                && isequal(numNei,obj.NumNeighbors) ...
                && isequal(d,obj.DistanceFcn) ...
                && isequal(dparam,obj.DistanceParam) ...
                && isequal(smtype,obj.SimpleModelType) ...
                && isequal(numsd,obj.NumSyntheticData) ...
                && isequal(kw,obj.KernelWidth)
                    return;
            end
            
            obj.QueryPoint = x;
            obj.NumImportantPredictors = k;
            obj.NumNeighbors = numNei;
            obj.DistanceFcn = d;
            obj.DistanceParam = dparam;
            obj.KernelWidth = kw;
            obj.SimpleModelType = smtype;
            obj.NumSyntheticData = numsd;
            
            % Make sure QueryPoint has the required form
            obj.QueryPoint = getPredictorTable(obj,obj.QueryPoint,'QueryPoint');

            obj = obj.errorCheck();
            obj.errorCheckCategoricals(); 
            % We do not need to collect obj here since we are not setting 
            % CategoricalPredictors in fit
            
            [obj,obj.QPmtx] = changeToLevels(obj,obj.QueryPoint);
            % generate local data if needed
            if strcmpi(obj.DataLocality,'local')
                obj = generateData(obj);            
            end
            
            % scale QueryPoint
            obj.QPmtx = scaleData(obj,obj.QPmtx);

            obj = fitsm(obj);
        end
        
        function f = plot(obj)
%PLOT Plot local interpretable model-agnostic explanations (LIME) results
%       F = PLOT(RESULTS) visualizes the LIME results in the lime object 
%       RESULTS. The function returns the Figure object F. Use F to query
%       or modify Figure Properties of the figure after it is created.
         
        if isempty(obj.SimpleModel)
            error(message('stats:lime:NoSimpleModel'));
        end
            if isa(obj.SimpleModel,'ClassificationTree') || isa(obj.SimpleModel,'RegressionTree')
                predImp = predictorImportance(obj.SimpleModel);
                [~,idx] = sort(predImp);
                idx = idx(end-sum(predImp>0)+1:end);
                betas = predImp(idx);
                prednames = obj.SimpleModel.PredictorNames;
            else              
                if isempty(obj.CategoricalPredictors)
                    [~,idx] = sort(abs(obj.SimpleModel.Beta));
                    betas = obj.SimpleModel.Beta(idx);
                    prednames = obj.SimpleModel.PredictorNames;
                else
                    h = groupcounts(obj.Groups(:));
                    h = h(obj.ImportantPredictors);
                    feats = zeros(1,sum(h));
                    cumh = 0;
                    for i=1:numel(h)
                        if h(i)>1
                            [~,midx] = max(abs(obj.SimpleModel.Beta(cumh+1:cumh+h(i))));
                            feats(cumh+midx) = 1;
                            cumh = cumh+h(i);
                        elseif h(i)==1
                            feats(cumh+1) = 1;
                            cumh = cumh+1;
                        end
                    end
                    levelbetas = obj.SimpleModel.Beta(logical(feats));
                    [~,idx] = sort(abs(levelbetas));
                    betas = levelbetas(idx);
                    prednames = classreg.learning.internal.expandPredictorNamesWithReference(obj.SimpleModel)';
                    prednames = prednames(logical(feats));
                end
            end 
            nt = find(betas);
            nidx = betas<0;
            b = barh(betas(nt));
            fnidx = find(nidx);
            for i = 1:length(fnidx)
                b.FaceColor = 'flat';
                b.CData(fnidx(i),:) = [0.8500 0.3250 0.0980];
            end
            ylabel(getString(message('stats:lime:Ylabel')))
            if strcmpi(obj.SimpleModelType,'linear')
                xlabel(getString(message('stats:lime:XlabelLinear')))
                title(getString(message('stats:lime:TitleLinear')))
            else
                xlabel(getString(message('stats:lime:XlabelTree')))
                title(getString(message('stats:lime:TitleTree')))
            end
            a = gca;
            set(a,'YTick',nt,'YTickLabel',prednames(idx));
            str1 = append(getString(message('stats:lime:BBPred'))," ",string(obj.BlackboxFitted));
            if strcmpi(obj.Type,'classification') && strcmpi(obj.SimpleModelType,'linear')
                if obj.SimpleModelFitted == 1
                    smpred = string(obj.BlackboxFitted);
                else
                    smpred = getString(message('stats:lime:NotY',string(obj.BlackboxFitted)));
                end
                str2 = append(getString(message('stats:lime:SMPred'))," ",smpred);
            else
                str2 = append(getString(message('stats:lime:SMPred'))," ",string(obj.SimpleModelFitted));
            end
            a.Subtitle.String = {str1,str2};
            f = gcf;
        end
    end
    
    methods(Access=private,Hidden=true)
        function obj = fitsm(obj)
            obj.BlackboxFitted = predictFromModel(obj.BlackboxModel,obj.QueryPoint);

            % compute distance
            if isempty(obj.CategoricalPredictors)
                if ~isempty(obj.DistanceParam)
                    dist = pdist2(obj.SDmtx,obj.QPmtx,obj.DistanceFcn,obj.DistanceParam);
                else
                    dist = pdist2(obj.SDmtx,obj.QPmtx,obj.DistanceFcn);
                end
            else
                dist = internal.stats.heteropdist2(obj.SDmtx,obj.QPmtx,obj.DistanceFcn,~obj.ContLogical);
            end
            
            % compute Weights
            width = sqrt(numel(obj.QueryPoint)) * obj.KernelWidth;
            obj.Weights = exp(-((dist/width).^2)./2);
            
            if all(obj.Weights==0)
                error(message('stats:lime:SmallKernelWidth'));
            end
            
            % if regression model, invoke fitrlime
            if strcmpi(obj.Type,'regression')
                if strcmpi(obj.SimpleModelType,'linear')
                    % dummify predictors
                    obj = dummifypredictors(obj);
                    obj = fitrlinearlime(obj);
                else
                    obj.SimpleModel = fitrtree(obj.SyntheticData, obj.Fitted, 'CategoricalPredictors',obj.CategoricalPredictors,'Weights', obj.Weights, 'PredictorNames', obj.VariableNames,'MaxNumSplits',obj.NumImportantPredictors);
                    obj.ImportantPredictors = 1:numel(obj.VariableNames);
                end
            else
                if strcmpi(obj.SimpleModelType,'linear')
                    % dummify predictors
                    obj = dummifypredictors(obj);
                    obj = fitclinearlime(obj);
                else
                    obj.SimpleModel = fitctree(obj.SyntheticData, obj.Fitted, 'CategoricalPredictors',obj.CategoricalPredictors,'Weights', obj.Weights, 'PredictorNames', obj.VariableNames,'MaxNumSplits',obj.NumImportantPredictors);
                    obj.ImportantPredictors = 1:numel(obj.VariableNames);
                end
            end
            obj.SimpleModelFitted = predictFromModel(obj.SimpleModel,obj.QueryPoint(:,obj.ImportantPredictors));

            if strcmpi(obj.SimpleModelType,'tree')
                obj.ImportantPredictors = find(predictorImportance(obj.SimpleModel)~=0);
            end
        end
        
        function obj = fitrlinearlime(obj)
            % Features selection
            obj.Features = classreg.learning.omputils.leastSquaresSaturatedGroupedOMP(obj.DummyX,obj.Fitted,obj.NumImportantPredictors,'Weights',obj.Weights,'Group',obj.Groups) ~= 0;
            if ~any(obj.Features)
                error(message('stats:lime:SmallNumSyntheticData'));
            end
            if isempty(obj.CategoricalPredictors)
                obj.ImportantPredictors = find(obj.Features); 
                obj.SimpleModel = fitrlinear(obj.SyntheticData(:,obj.ImportantPredictors), ...
                    obj.Fitted,'Weights',obj.Weights,'Solver','lbfgs', ...
                    'Lambda',0,'Learner','leastsquares', ...
                    'PredictorNames',obj.VariableNames(obj.ImportantPredictors));
            else
                obj.ImportantPredictors = unique(obj.Groups(obj.Features));
                obj.SimpleModel = fitrlinear(obj.SyntheticData(:,obj.ImportantPredictors), ...
                    obj.Fitted,'Weights',obj.Weights, ...
                    'ReferenceLevels', obj.QueryPoint(:,obj.ImportantPredictors), ...
                    'CategoricalPredictors',ismember(obj.ImportantPredictors,obj.CategoricalPredictors), ...
                    'Solver','lbfgs','Lambda',0,'Learner','leastsquares', ...
                    'PredictorNames',obj.VariableNames(obj.ImportantPredictors));
            end
        end
        
        function obj = fitclinearlime(obj)
            % Features selection
            % change blackbox fitted to levels for multi-class classification
            [~,~,ic] = unique([obj.BlackboxFitted; obj.Fitted]);
            dataY = ic(2:end);
            % change y to -1/1 class labels or to one versus all
            dataY(ic(1)~=ic(2:end)) = -1;
            dataY(ic(1)==ic(2:end)) = 1;
            obj.Features = classreg.learning.omputils.logisticSaturatedGroupedOMP(obj.DummyX,dataY,obj.NumImportantPredictors,'Weights',obj.Weights,'Group',obj.Groups) ~= 0;
            if ~any(obj.Features)
                error(message('stats:lime:SmallNumSyntheticData'));
            end
            if isempty(obj.CategoricalPredictors)
                obj.ImportantPredictors = find(obj.Features);
                obj.SimpleModel = fitclinear(obj.SyntheticData(:,obj.ImportantPredictors), ...
                    dataY,'Weights',obj.Weights,'Solver','lbfgs','Lambda',0, ...
                    'Learner','logistic', ...
                    'PredictorNames',obj.VariableNames(obj.ImportantPredictors));
            else
                obj.ImportantPredictors = unique(obj.Groups(obj.Features));
                obj.SimpleModel = fitclinear(obj.SyntheticData(:,obj.ImportantPredictors), ...
                    dataY,'Weights',obj.Weights, ...
                    'ReferenceLevels',obj.QueryPoint(:,obj.ImportantPredictors), ...
                    'CategoricalPredictors',ismember(obj.ImportantPredictors,obj.CategoricalPredictors), ...
                    'Solver','lbfgs','Lambda',0,'Learner','logistic', ...
                    'PredictorNames',obj.VariableNames(obj.ImportantPredictors));
            end
        end
        
        function obj = generateData(obj)
            obj.SyntheticData = [];
            obj.SDmtx = [];
            if isempty(obj.CategoricalPredictors)
                obj.SyntheticData = generateContData(obj,obj.Xmtx);
                obj.SDmtx = obj.SyntheticData;
            else
                obj = generateCatData(obj);
            end
            if istable(obj.X) && ~istable(obj.SyntheticData)
                obj.SyntheticData = array2table(obj.SyntheticData,'VariableNames',obj.VariableNames);
            elseif ~istable(obj.X) && istable(obj.SyntheticData)
                obj.SyntheticData = table2array(obj.SyntheticData);
            end
            
            % make Fitteds for generated data using blackbox model
            if isa(obj.BlackboxModel,'function_handle')
                obj.Fitted = obj.BlackboxModel(obj.SyntheticData);
            else
                obj.Fitted = obj.BlackboxModel.predict(obj.SyntheticData);
            end
            
            obj.Fitted = predictFromModel(obj.BlackboxModel,obj.SyntheticData);

            if isa(obj.BlackboxModel,'function_handle')
                obj.Fitted = obj.BlackboxModel(obj.SyntheticData);
            else
                obj.Fitted = obj.BlackboxModel.predict(obj.SyntheticData);
            end
            if any(ismissing(obj.Fitted))
                eror(message('stats:lime:NaNFitted'));
            end
            % scale data
            % obj.SDmtx will be NumSyntheticData by D where D is the
            % number of predictors in X or CustomSyntheticData. MinSD
            % and MaxSD will be 1 by D vectors containing the min and
            % max of each predictor in numeric form.
            obj.MinSD = min(obj.SDmtx,[],1);
            obj.MaxSD = max(obj.SDmtx,[],1);
            obj.SDmtx = scaleData(obj,obj.SDmtx);
        end
        
        function cdata = generateContData(obj,data)            
            % if all predictors were categorical, we do not need to
            % generate cont data
            if numel(obj.VariableNames) == numel(obj.CategoricalPredictors)
                cdata = [];
                return;
            end
            n = obj.NumSyntheticData;
            
            % generate data locally versus globally
            if strcmpi(obj.DataLocality,'local') && isempty(obj.CategoricalPredictors)
                if ~isempty(obj.DistanceParam)
                     [~,idx] = pdist2(data,obj.QPmtx,obj.DistanceFcn,obj.DistanceParam,'Smallest',obj.NumNeighbors);
                else
                    [~,idx] = pdist2(data,obj.QPmtx,obj.DistanceFcn,'Smallest',obj.NumNeighbors);
                end
                data = data(idx,:);
            end
            sameval_idx = false(1,size(data,2));
            minX = min(data,[],1);
            maxX = max(data,[],1);
            if any(minX==maxX)
                sameval_idx = minX==maxX;
            end
            % normal distribution around the mean
            try
                cdata = mvnrnd(mean(data,1,'omitnan'),cov(data,'omitrows'),n);
            catch
                error(message('stats:lime:BadTrainingData'));
            end
            % if any predictor had the same min and max, set all the
            % observations for this prediction in synthetic data too to the
            % same value
            for i=1:length(minX)
                if sameval_idx(i)
                    cdata(:,i) = minX(i);
                end
            end
        end
        
        function obj = generateCatData(obj)
            contPreds = setdiff(1:numel(obj.VariableNames),obj.CategoricalPredictors);
            n = obj.NumSyntheticData;
            nCat = numel(obj.CategoricalPredictors);
                        
            if strcmpi(obj.DataLocality,'local')
                dist = internal.stats.heteropdist2(obj.Xmtx,obj.QPmtx,obj.DistanceFcn,~obj.ContLogical);
                [~,idx] = sort(dist);
                data = obj.Xmtx(idx(1:obj.NumNeighbors),:);
            else
                data = obj.Xmtx;
            end
            % cont preds
            contData = generateContData(obj,data(:,obj.ContLogical));
            
            catData = table;
            catDataLevel = data(:,obj.CategoricalPredictors);
            for i=1:nCat
                alphabet = catDataLevel(:,i);
                [b,bg] = groupcounts(alphabet(:),'IncludeMissingGroups',false);
                prob = b/sum(b);                
                cdata = datasample(bg,n,'Weights',prob);
               if size(obj.AlphabetX,2)>=i && ~isempty(obj.AlphabetX{i})
                    alphaData = obj.AlphabetX{i}(cdata); % to convert it back to alphabet
                    catData(:,i) = array2table(alphaData);
                else
                    catData(:,i) = array2table(cdata);
                end
                obj.SDmtx(:,obj.CategoricalPredictors(i)) = cdata;
            end

            % combine them
            t1 = array2table(contData,'VariableNames',obj.VariableNames(contPreds));
            catData.Properties.VariableNames(:) = obj.VariableNames(obj.CategoricalPredictors);
            obj.SyntheticData = [t1 catData];            
            obj.SyntheticData = obj.SyntheticData(:,obj.VariableNames);
            
            obj.SDmtx(:,obj.ContLogical) = contData;
        end
        
        function [obj,data] = changeToLevels(obj,data)
            % returns matrix data with index of alphabet (or
            % level of category)
            if isa(data,'table')
                if isempty(obj.AlphabetX)
                   for i=1:numel(obj.CategoricalPredictors)
                        predictor = obj.CategoricalPredictors(i);
                        [obj.AlphabetX{i},~,ic] = unique(data.(predictor));
                        data.(predictor) = ic;
                    end
                else   
                     for i=1:numel(obj.CategoricalPredictors)
                        predictor = obj.CategoricalPredictors(i);
                        [~,data.(predictor)] = ismember(table2array(data(:,predictor)),obj.AlphabetX{i});
                     end
                end
                data = table2array(data);
            else
                if isempty(obj.AlphabetX)
                    for i=1:numel(obj.CategoricalPredictors)
                        predictor = obj.CategoricalPredictors(i);
                        [obj.AlphabetX{i},~,ic] = unique(data(:,predictor));
                        data(:,predictor) = ic;
                    end
                else
                    for i=1:numel(obj.CategoricalPredictors)
                        predictor = obj.CategoricalPredictors(i);
                        [~,data(:,predictor)] = ismember(data(:,predictor),obj.AlphabetX{i}); 
                    end
                end
            end
        end
        
        function obj = errorCheck(obj)
            % perform various checks on NV pairs
            
            % check X
            if size(obj.X,1) == 1 || (isempty(obj.X) && isempty(obj.SyntheticData))
                % A check for empty X is done in the beginning. This
                % condition for empty X will be true if the user had 
                % provided X and all of them have missing values. 
                error(message('stats:lime:SmallTrainingData'));
            end
            
            % check query point
            if ~isempty(obj.QueryPoint)
                if ~istable(obj.QueryPoint) ...
                        && ~ismatrix(obj.QueryPoint)
                    error(message('stats:lime:InvalidQueryPoint'));
                elseif size(obj.QueryPoint,1)>1
                    error(message('stats:lime:VectorQueryPoint'));
                elseif any(ismissing(obj.QueryPoint))
                    error(message('stats:lime:MissingValQP'));
                else
                    try
                        predictFromModel(obj.BlackboxModel,obj.QueryPoint);
                    catch
                        error(message('stats:lime:BadQueryPoint'));
                    end
                    % make sure query point does not have a new category
                    % not in X or SyntheticData
                    if ~isempty(obj.X)
                        data = obj.X;
                    else
                        data = obj.SyntheticData;
                    end
                    for pred = obj.CategoricalPredictors                        
                        if istable(obj.QueryPoint)
                            [~,idx] = ismember(obj.QueryPoint(:,pred),data(:,pred));
                        else
                            [~,idx] = ismember(obj.QueryPoint(pred),data(:,pred));
                        end
                        if ~idx
                            error(message('stats:lime:NewCategoryQP'));
                        end
                    end
                end
            end
            
            % check NumImportantPredictors
            if ~isempty(obj.NumImportantPredictors)
                if ~isscalar(obj.NumImportantPredictors) ...
                        || mod(obj.NumImportantPredictors,1)~=0
                    error(message('stats:lime:VectorNumImprtantPredictors'));
                elseif obj.NumImportantPredictors > numel(obj.VariableNames)
                    error(message('stats:lime:LargeNumImportantPredictors'));
                elseif obj.NumImportantPredictors <=0
                    error(message('stats:lime:NonPositiveNumImportantPredictors'));
                end
            end
             
            % check NumNeighbors
            if ~isscalar(obj.NumNeighbors) ...
                        || mod(obj.NumNeighbors,1)~=0
                    error(message('stats:lime:BadNumNeighbors'));
            elseif isempty(obj.SyntheticData) ...
                    && (obj.NumNeighbors > size(obj.Xmtx,1))
                  obj.NumNeighbors = size(obj.Xmtx,1);
            elseif obj.NumNeighbors <=0
                error(message('stats:lime:NonPositiveNumNeighbors'));
            end
            
            % check KernelWidth
            if ~isscalar(obj.KernelWidth) ...
                        || obj.KernelWidth>1 ...
                        || obj.KernelWidth<=0
                    error(message('stats:lime:BadKernelWidth'));
            end
            
            % check SimpleModelType
            if ~strcmpi(obj.SimpleModelType,'linear') ...
                    && ~strcmpi(obj.SimpleModelType,'tree')
                error(message('stats:lime:InvalidSimpleModelType'));
            end
            
            % check NumSyntheticData
            if ~isscalar(obj.NumSyntheticData) ...
                        || mod(obj.NumSyntheticData,1)~=0
                    error(message('stats:lime:BadNumSyntheticData'));
            elseif obj.NumSyntheticData <=0
                error(message('stats:lime:NonPositiveNumSyntheticData'));
            end    
            
            % check distance
            if isempty(obj.CategoricalPredictors)
                validatestring(obj.DistanceFcn,{'euclidean','squaredeuclidean', ...
                    'seuclidean','mahalanobis','cityblock','minkowski', ...
                    'chebychev','cosine','correlation','spearman'});
            else
                validatestring(obj.DistanceFcn,{'goodall3','ofd'});
            end
        end
        
        function dparam = errorCheckDistParam(~,dist,p,scale,cov)
            dparam = [];
            if ~isempty(p) 
                if strcmpi(dist,'minkowski')
                    dparam = p;
                else
                    error(message('stats:ExhaustiveSearcher:knnsearch:InvalidMinExp'));
                end
            end
            if ~isempty(scale) 
                if strcmpi(dist,'seuclidean')
                    dparam = scale;
                else
                    error(message('stats:ExhaustiveSearcher:knnsearch:InvalidSeucInvWgt'));
                end
            end
            if ~isempty(cov) 
                if strcmpi(dist,'mahalanobis')
                    dparam = cov;
                else
                    error(message('stats:ExhaustiveSearcher:knnsearch:InvalidMahaCov'));
                end
            end
        end
        
        function obj = errorCheckCategoricals(obj)
            XCatPreds = [];
            SDCatPreds = [];
            QPCatPreds = [];
            if ~isempty(obj.X)
                XCatPreds = extractCatPreds(obj,obj.X);
            end
            if ~isempty(obj.SyntheticData)
                SDCatPreds = extractCatPreds(obj,obj.SyntheticData);
            end
            if ~isempty(obj.QueryPoint)
                QPCatPreds = extractCatPreds(obj,obj.QueryPoint);
            end
            % make sure X, SD, QP match
            if sum([isempty(XCatPreds),isempty(SDCatPreds),isempty(QPCatPreds)])<=1 && ...
                    (~isequal(XCatPreds,SDCatPreds,QPCatPreds) && ...
                    ~(isequal(XCatPreds,SDCatPreds) && isempty(QPCatPreds)) && ...
                    ~(isequal(XCatPreds,QPCatPreds) && isempty(SDCatPreds)) && ...
                    ~(isequal(QPCatPreds,SDCatPreds) && isempty(XCatPreds)))
                error(message('stats:lime:DiffXQPSD'));
            end
            % When Blackbox is provided, NVP CategoricalPredictors must match
            if ~isa(obj.BlackboxModel,'function_handle')
                bbCatPreds = obj.BlackboxModel.CategoricalPredictors;
                if any(~ismember(obj.CategoricalPredictors,bbCatPreds))
                    error(message('stats:lime:DiffBBandNVP'));
                end
                obj.CategoricalPredictors = bbCatPreds;
            % NVP, X, Synthetic Data, Query Point must all match
            else
                extractedCatPreds = union([XCatPreds,SDCatPreds],QPCatPreds);
                if any(~ismember(extractedCatPreds(:),obj.CategoricalPredictors')) && ...
                    ~isempty(extractedCatPreds) && ...
                    ~isempty(obj.CategoricalPredictors)
                    error(message('stats:lime:DiffAll'));
                end
                if isempty(obj.CategoricalPredictors)
                    obj.CategoricalPredictors = extractedCatPreds(:);
                end
            end
        end
        
        function catPreds = extractCatPreds(~,data)
            catPreds = [];
            if isa(data,'table')
                % represent cat preds by numeric levels
                % if user did not provide categorical predictors, try to
                % detect it
                types = varfun(@class,data,'OutputFormat','cell');
                condition = contains(types,'categorical') ...
                    | contains(types,'char') ...
                    | contains(types,'string') ...
                    | contains(types,'logical')...
                    | contains(types,'cell');
                if any(condition)
                    catPreds = find(condition);
                end
            end
        end
            
        function obj = dummifypredictors(obj)
           % should dummify numeric obj.SD to numeric mtx of many cols
           obj.DummyX = [];
           if isempty(obj.CategoricalPredictors)
               obj.DummyX = obj.SDmtx;
           else
               trueidx = 1;
               catid = 0;
                for i=1:numel(obj.ContLogical)
                    if obj.ContLogical(i)
                        obj.Groups(trueidx) = i;
                        obj.DummyX(:,trueidx) = obj.SDmtx(:,i);
                        trueidx = trueidx+1;
                    else
                        dv1 = dummyvar([obj.QPmtx(:,i); obj.SDmtx(:,i)]);
                        % find col where dv1(1,:)=1 -> this is the column
                        % representing the level of query pt
                        % remove this col from dv1
                        dv1(:,logical(dv1(1,:))) = [];
                        numcols = numel(dv1(1,:));
                        dv1(1,:) = [];
                        obj.DummyX(:,trueidx:trueidx+numcols-1) = dv1;
                        obj.Groups(trueidx:trueidx+numcols-1) = ones(1,numcols)*i;
                        % get new predictor names as per categorical levels
                        catid = catid+1;
                        trueidx = trueidx+numcols;
                    end
                end
           end
        end      
        
        function data = scaleData(obj,data)
            idx = false(1,numel(obj.ContLogical));
            if any(obj.MinSD == obj.MaxSD)
                idx = obj.MinSD == obj.MaxSD;
                data(:,idx) = 1;
            end
            remaining_idx = obj.ContLogical&~idx;
            data(:,remaining_idx) = (data(:,remaining_idx) ...
                -obj.MinSD(:,remaining_idx))./(obj.MaxSD(:,remaining_idx) ...
                -obj.MinSD(:,remaining_idx));
        end      
        function xout = getPredictorTable(obj,xin,xname)
            model = obj.BlackboxModel;
            if isempty(xin)
                % Empty/default, just pass it back out
                xout = xin;
            elseif isa(model,'function_handle')
                % We cannot figure out what the model expects, so just take
                % the input data
                xout = xin;
            elseif ~istable(xin)
                % The best we can do is check that we have the correct
                % number of columns
                if isempty(obj.VariableNames)
                    numExpected = length(model.PredictorNames);
                else
                    numExpected = length(obj.VariableNames);
                end
                if size(xin,2)~=numExpected
                    error(message('stats:lime:WrongNumberPredictors',xname,numExpected));
                end
                xout = xin;
            else
                % Get the required predictors from the input data
                requiredNames = obj.BlackboxModel.PredictorNames;
                suppliedNames = xin.Properties.VariableNames;
                tf = ismember(requiredNames,suppliedNames);
                if any(~tf)
                    notfound = find(~tf,1);
                    error(message('stats:lime:MissingPredictor',requiredNames{notfound},xname));
                else
                    xout = xin(:,requiredNames);
                end
            end
        end
    end
end

function out = predictFromModel(model,data)
% Predict from model, taking care to convert chars to cellstr because OMP
% code does not support chars.
if isa(model,'function_handle')
    out = model(data);
else
    out = predict(model,data);
end
if ischar(out)
    out = cellstr(out);
end
end


